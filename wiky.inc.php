<?php
/* Wiky.php - крошечная PHP-библиотека для преобразования вики-разметки в HTML
 * Автор: Тони Ляхдекорпи <toni@lygon.net>
 *
 * Использование кода разрешено на условиях любой из следующих лицензий:
 * Apache License 2.0, http://www.apache.org/licenses/LICENSE-2.0
 * Mozilla Public License 1.1, http://www.mozilla.org/MPL/1.1/
 * GNU Lesser General Public License 3.0, http://www.gnu.org/licenses/lgpl-3.0.html
 * GNU General Public License 2.0, http://www.gnu.org/licenses/gpl-2.0.html
 * Creative Commons Attribution 3.0 Unported License, http://creativecommons.org/licenses/by/3.0/
 */

class wiky {
	private $patterns, $replacements;

	public function __construct($analyze=false) {
		$this->patterns=array(
			"/\r\n/",
			
			// Заголовки
			"/^==== (.+?) ====$/m",						// Подподзаголовок
			"/^=== (.+?) ===$/m",							// Подзаголовок
			"/^== (.+?) ==$/m",							// Заголовок
			"/^= (.+?) =$/m",							// Название
	
			// Форматирование
			"/\'\'\'\'\'(.+?)\'\'\'\'\'/s",					// Жирный курсив
			"/\'\'\'(.+?)\'\'\'/s",							// Жирный
			"/\'\'(.+?)\'\'/s",							// Курсив
	
			// Специальные элементы
			"/^----+(\s*)$/m",						// Горизонтальная линия
			"/\[\[(file|img):((ht|f)tp(s?):\/\/(.+?))( (.+))*\]\]/i",	// (file|img):(http|https|ftp) — изображение
			"/\[((news|(ht|f)tp(s?)|irc):\/\/(.+?))( (.+))\]/i",		// Другие URL с текстом
			"/\[((news|(ht|f)tp(s?)|irc):\/\/(.+?))\]/i",				  // Другие URL без текста
			"/\[\[([^|\]]+)\|([^\]]+)\]\]/",			                        // Внутренние ссылки с текстом
			"/\[\[([^\]]+)\]\]/",			                                         // Внутренние ссылки без текста
	
			// Отступы
			"/[\n\r]: *.+([\n\r]:+.+)*/",					// Отступы, первый проход
			"/^:(?!:) *(.+)$/m",						// Отступы, второй проход
			"/([\n\r]:: *.+)+/",						// Вложенные отступы, первый проход
			"/^:: *(.+)$/m",						// Вложенные отступы, второй проход
	
			// Нумерованный список
			"/[\n\r]?#.+([\n|\r]#.+)+/",					// Первый проход, поиск всех блоков
			"/[\n\r]#(?!#) *(.+)(([\n\r]#{2,}.+)+)/",			// Элемент списка с подэлементами уровня 2 и более
			"/[\n\r]#{2}(?!#) *(.+)(([\n\r]#{3,}.+)+)/",			// Элемент списка с подэлементами уровня 3 и более
			"/[\n\r]#{3}(?!#) *(.+)(([\n\r]#{4,}.+)+)/",			// Элемент списка с подэлементами уровня 4 и более
	
			// Ненумерованный список
			"/[\n\r]?\*.+([\n|\r]\*.+)+/",					// Первый проход, поиск всех блоков
			"/[\n\r]\*(?!\*) *(.+)(([\n\r]\*{2,}.+)+)/",			// Элемент списка с подэлементами уровня 2 и более
			"/[\n\r]\*{2}(?!\*) *(.+)(([\n\r]\*{3,}.+)+)/",		// Элемент списка с подэлементами уровня 3 и более
			"/[\n\r]\*{3}(?!\*) *(.+)(([\n\r]\*{4,}.+)+)/",		// Элемент списка с подэлементами уровня 4 и более
	
			// Элементы списков
			"/^[#\*]+ *(.+)$/m",						// Оборачивает все элементы списка в <li/>
	
			// Переносы строк (TODO: сделать умнее, чтобы группировались в абзацы)
			"/^(?!<li|dd).+(?=(<a|strong|em|img)).+$/mi",			// Строки с разрываемыми элементами (TODO: исправить эту фигню, сравнение с li|dd здесь глупое)
			"/^[^><\n\r]+$/m",						// Строки без элементов
		);
		$this->replacements=array(
			"\n",
			
			// Заголовки
			"<h4>$1</h4>",
			"<h3>$1</h3>",
			"<h2>$1</h2>",
			"<h1>$1</h1>",
	
			// Форматирование
			"<strong><em>$1</em></strong>",
			"<strong>$1</strong>",
			"<em>$1</em>",
	
			// Специальные элементы
			"<hr/>",
			"<img src=\"$2\" alt=\"$6\"/>",
			"<a href=\"$1\">$7</a>",
			"<a href=\"$1\">$1</a>",
			"<a href=\"?Page=$1\">$2</a>",
			"<a href=\"?Page=$1\">$1</a>",
	
			// Отступы
			"\n<dl>$0\n</dl>", // Перевод строки здесь нужен для упрощения второго прохода
			"<dd>$1</dd>",
			"\n<dd><dl>$0\n</dl></dd>",
			"<dd>$1</dd>",
	
			// Нумерованный список
			"\n<ol>\n$0\n</ol>",
			"\n<li>$1\n<ol>$2\n</ol>\n</li>",
			"\n<li>$1\n<ol>$2\n</ol>\n</li>",
			"\n<li>$1\n<ol>$2\n</ol>\n</li>",
	
			// Ненумерованный список
			"\n<ul>\n$0\n</ul>",
			"\n<li>$1\n<ul>$2\n</ul>\n</li>",
			"\n<li>$1\n<ul>$2\n</ul>\n</li>",
			"\n<li>$1\n<ul>$2\n</ul>\n</li>",
	
			// Элементы списков
			"<li>$1</li>",
	
			// Переносы строк
			"$0<br/>",
			"$0<br/>",
		);
		if($analyze) {
			foreach($this->patterns as $k=>$v) {
				$this->patterns[$k].="S";
			}
		}
	}
	public function parse($input) {
		if(!empty($input))
			$output=preg_replace($this->patterns,$this->replacements,$input);
		else
			$output=false;
		return $output;
	}
}
